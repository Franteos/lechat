=pod
-----BEGIN PGP SIGNED MESSAGE-----

/####################################################################
#                                                                   #
#    MessageImage - EXAMPLE CAPTCHA MODULE for LE CHAT 2.0          #
#                                                                   #
#    Adaption of "Message Image" which can be found here:           #
#    http://www.scss.com.au/family/andrew/webdesign/msgimg/         #
#                                                                   #
#    LeCaptchaMessageImage.pm - Last changed: 2018-01-04            #
#                                                                   #
####################################################################/
=cut

package LeCaptchaMessageImage;
use strict;
no warnings 'uninitialized';

sub generate_challenge{
	my($MODULE,$QUERY,$CONFIG,$CAPTCHA,$INT)=@_;
	$CAPTCHA->{solution}=random_text(4,'A'..'Z','a'..'z','0'..'9','!()=<>$?');
	return qq|<br><table><tr><td valign="middle"><img src="<IMAGE>" alt="CAPTCHA"></td><td valign="middle"><input type="text" name="answer" size="8" value=""></td></tr></table>|;
}

sub verify_response{
	my($MODULE,$QUERY,$CONFIG,$CAPTCHA,$INT)=@_;
	return 1 if($CAPTCHA->{solution} eq $QUERY->{answer}[0]);
	return 0;
}

sub output_image{
	my($MODULE,$QUERY,$CONFIG,$CAPTCHA,$INT)=@_;
	print "Pragma: no-cache\nExpires: 0\n";
	binmode STDOUT;
	do_msg_image($CAPTCHA->{solution});
}

sub random_text{
	my $count=shift;
	my @chars=split('',join('',@_));
	my $text;
	$text.=$chars[rand@chars]for 1..$count;
	return $text;
}

#####################################################################
# The following lines are a verbatim copy of the file "msgimg.pl"   #
#####################################################################

#!/usr/bin/perl -w
# Generate GIF image of a message
# Version 1.5
# by Andrew Gregory
# 17 February 2007
#
# http://www.scss.com.au/family/andrew/webdesign/msgimg/
#
# This work is licensed under the Creative Commons
# Attribution-NonCommercial-ShareAlike License. To view a copy of this license,
# visit http://creativecommons.org/licenses/by-nc-sa/1.0/ or send a letter to
# Creative Commons, 559 Nathan Abbott Way, Stanford, California 94305, USA.

# $msg - The message to display.
# $transidx - The palette index of the transparent colour. May be undef.
sub do_msg_image {
my($msg, $transidx) = @_;
my($BITS_PER_PIXEL);

$BITS_PER_PIXEL = 4;

###############################################
# Palette
#
# Define using red-green-blue triplets.
my($palette);
$palette .= "\xFF\xFF\xFF"; # 0 = white
$palette .= "\x66\x66\x66"; # 1 = grey
$palette .= "\x99\x99\x99";
$palette .= "\x33\x33\x33"; # 3 = almost black
$palette .= "\x11\x11\x11";
$palette .= "\x00\x00\x00";

###############################################
# Dot definition
#
# Defines a dot in terms of palette colours.
my($DOT_WIDTH, $DOT_HEIGHT, $dot, $nodot);

$DOT_WIDTH = 3;
$DOT_HEIGHT = 3;

$dot = qq~
\1\3\1
\3\3\3
\1\3\1
~;
$nodot = qq~
\0\0\0
\0\0\0
\0\0\0
~;
#
###############################################

###############################################
# Character definitions
my($CHAR_WIDTH, $CHAR_HEIGHT, %ci);

$CHAR_WIDTH = 6;
$CHAR_HEIGHT = 9;

$ci{' '} = qq~
......
......
......
......
......
......
......
......
......
~;
$ci{'!'} = qq~
..X...
..X...
..X...
..X...
..X...
......
..X...
......
......
~;
$ci{'"'} = qq~
.X.X..
.X.X..
.X.X..
......
......
......
......
......
......
~;
$ci{'#'} = qq~
.X.X..
.X.X..
XXXXX.
.X.X..
XXXXX.
.X.X..
.X.X..
......
......
~;
$ci{'$'} = qq~
..X...
.XXXX.
X.X...
.XXX..
..X.X.
XXXX..
..X...
......
......
~;
$ci{'%'} = qq~
XX....
XX..X.
...X..
..X...
.X....
X..XX.
...XX.
......
......
~;
$ci{'&'} = qq~
.X....
X.X...
X.X...
.X....
X.X.X.
X..X..
.XX.X.
......
......
~;
$ci{'\''} = qq~
..X...
..X...
..X...
......
......
......
......
......
......
~;
$ci{'('} = qq~
...X..
..X...
.X....
.X....
.X....
..X...
...X..
......
......
~;
$ci{')'} = qq~
.X....
..X...
...X..
...X..
...X..
..X...
.X....
......
......
~;
$ci{'*'} = qq~
..X...
X.X.X.
.XXX..
..X...
.XXX..
X.X.X.
..X...
......
......
~;
$ci{'+'} = qq~
......
..X...
..X...
XXXXX.
..X...
..X...
......
......
......
~;
$ci{','} = qq~
......
......
......
......
......
..X...
..X...
.X....
......
~;
$ci{'-'} = qq~
......
......
......
XXXXX.
......
......
......
......
......
~;
$ci{'.'} = qq~
......
......
......
......
......
......
..X...
......
......
~;
$ci{'/'} = qq~
......
....X.
...X..
..X...
.X....
X.....
......
......
......
~;
$ci{':'} = qq~
......
......
......
..X...
......
..X...
......
......
......
~;
$ci{';'} = qq~
......
......
......
..X...
......
..X...
..X...
.X....
......
~;
$ci{'<'} = qq~
...X..
..X...
.X....
X.....
.X....
..X...
...X..
......
......
~;
$ci{'='} = qq~
......
......
XXXXX.
......
XXXXX.
......
......
......
......
~;
$ci{'>'} = qq~
.X....
..X...
...X..
....X.
...X..
..X...
.X....
......
......
~;
$ci{'?'} = qq~
.XXX..
X...X.
...X..
..X...
..X...
......
..X...
......
......
~;
$ci{'@'} = qq~
.XXX..
X...X.
X.X.X.
X.XXX.
X.XX..
X.....
.XXXX.
......
......
~;
$ci{'['} = qq~
XXXXX.
XX....
XX....
XX....
XX....
XX....
XXXXX.
......
......
~;
$ci{'\\'} = qq~
......
X.....
.X....
..X...
...X..
....X.
......
......
......
~;
$ci{']'} = qq~
XXXXX.
...XX.
...XX.
...XX.
...XX.
...XX.
XXXXX.
......
......
~;
$ci{'^'} = qq~
......
......
..X...
.X.X..
X...X.
......
......
......
......
~;
$ci{'_'} = qq~
......
......
......
......
......
......
XXXXX.
......
......
~;
$ci{'`'} = qq~
..X...
..X...
...X..
......
......
......
......
......
......
~;
$ci{'{'} = qq~
...XX.
..X...
..X...
.X....
..X...
..X...
...XX.
......
......
~;
$ci{'|'} = qq~
..X...
..X...
..X...
......
..X...
..X...
..X...
......
......
~;
$ci{'}'} = qq~
.XX...
...X..
...X..
....X.
...X..
...X..
.XX...
......
......
~;
$ci{'~'} = qq~
.X....
X.X.X.
...X..
......
......
......
......
......
......
~;
$ci{'0'} = qq~
.XXX..
X...X.
X..XX.
X.X.X.
XX..X.
X...X.
.XXX..
......
......
~;
$ci{'1'} = qq~
..X...
.XX...
..X...
..X...
..X...
..X...
.XXX..
......
......
~;
$ci{'2'} = qq~
.XXX..
X...X.
....X.
..XX..
.X....
X.....
XXXXX.
......
......
~;
$ci{'3'} = qq~
XXXXX.
....X.
...X..
..XX..
....X.
X...X.
.XXX..
......
......
~;
$ci{'4'} = qq~
...X..
..XX..
.X.X..
X..X..
XXXXX.
...X..
...X..
......
......
~;
$ci{'5'} = qq~
XXXXX.
X.....
XXXX..
....X.
....X.
X...X.
.XXX..
......
......
~;
$ci{'6'} = qq~
..XXX.
.X....
X.....
XXXX..
X...X.
X...X.
.XXX..
......
......
~;
$ci{'7'} = qq~
XXXXX.
....X.
...X..
..X...
.X....
.X....
.X....
......
......
~;
$ci{'8'} = qq~
.XXX..
X...X.
X...X.
.XXX..
X...X.
X...X.
.XXX..
......
......
~;
$ci{'9'} = qq~
.XXX..
X...X.
X...X.
.XXXX.
....X.
...X..
XXX...
......
......
~;
$ci{'A'} = qq~
..X...
.X.X..
X...X.
X...X.
XXXXX.
X...X.
X...X.
......
......
~;
$ci{'a'} = qq~
......
......
.XXX..
....X.
.XXXX.
X...X.
.XXXX.
......
......
~;
$ci{'B'} = qq~
XXXX..
X...X.
X...X.
XXXX..
X...X.
X...X.
XXXX..
......
......
~;
$ci{'b'} = qq~
X.....
X.....
XXXX..
X...X.
X...X.
X...X.
XXXX..
......
......
~;
$ci{'C'} = qq~
.XXX..
X...X.
X.....
X.....
X.....
X...X.
.XXX..
......
......
~;
$ci{'c'} = qq~
......
......
.XXXX.
X.....
X.....
X.....
.XXXX.
......
......
~;
$ci{'D'} = qq~
XXXX..
X...X.
X...X.
X...X.
X...X.
X...X.
XXXX..
......
......
~;
$ci{'d'} = qq~
....X.
....X.
.XXXX.
X...X.
X...X.
X...X.
.XXXX.
......
......
~;
$ci{'E'} = qq~
XXXXX.
X.....
X.....
XXXX..
X.....
X.....
XXXXX.
......
......
~;
$ci{'e'} = qq~
......
......
.XXX..
X...X.
XXXXX.
X.....
.XXXX.
......
......
~;
$ci{'F'} = qq~
XXXXX.
X.....
X.....
XXXX..
X.....
X.....
X.....
......
......
~;
$ci{'f'} = qq~
..XX..
.X..X.
.X....
XXXX..
.X....
.X....
.X....
......
......
~;
$ci{'G'} = qq~
.XXXX.
X.....
X.....
X.....
X..XX.
X...X.
.XXXX.
......
......
~;
$ci{'g'} = qq~
......
......
.XXX..
X...X.
X...X.
.XXXX.
....X.
.XXX..
......
~;
$ci{'H'} = qq~
X...X.
X...X.
X...X.
XXXXX.
X...X.
X...X.
X...X.
......
......
~;
$ci{'h'} = qq~
X.....
X.....
XXXX..
X...X.
X...X.
X...X.
X...X.
......
......
~;
$ci{'I'} = qq~
.XXX..
..X...
..X...
..X...
..X...
..X...
.XXX..
......
......
~;
$ci{'i'} = qq~
..X...
......
.XX...
..X...
..X...
..X...
.XXX..
......
......
~;
$ci{'J'} = qq~
....X.
....X.
....X.
....X.
....X.
X...X.
.XXX..
......
......
~;
$ci{'j'} = qq~
...X..
......
..XX..
...X..
...X..
...X..
X..X..
.XX...
......
~;
$ci{'K'} = qq~
X...X.
X..X..
X.X...
XX....
X.X...
X..X..
X...X.
......
......
~;
$ci{'k'} = qq~
X.....
X.....
X...X.
X..X..
XXX...
X..X..
X...X.
......
......
~;
$ci{'L'} = qq~
X.....
X.....
X.....
X.....
X.....
X.....
XXXXX.
......
......
~;
$ci{'l'} = qq~
.XX...
..X...
..X...
..X...
..X...
..X...
.XXX..
......
......
~;
$ci{'M'} = qq~
X...X.
XX.XX.
X.X.X.
X.X.X.
X...X.
X...X.
X...X.
......
......
~;
$ci{'m'} = qq~
......
......
XX.XX.
X.X.X.
X.X.X.
X.X.X.
X...X.
......
......
~;
$ci{'N'} = qq~
X...X.
X...X.
XX..X.
X.X.X.
X..XX.
X...X.
X...X.
......
......
~;
$ci{'n'} = qq~
......
......
XXXX..
X...X.
X...X.
X...X.
X...X.
......
......
~;
$ci{'O'} = qq~
.XXX..
X...X.
X...X.
X...X.
X...X.
X...X.
.XXX..
......
......
~;
$ci{'o'} = qq~
......
......
.XXX..
X...X.
X...X.
X...X.
.XXX..
......
......
~;
$ci{'P'} = qq~
XXXX..
X...X.
X...X.
XXXX..
X.....
X.....
X.....
......
......
~;
$ci{'p'} = qq~
......
......
XXXX..
X...X.
X...X.
XXXX..
X.....
X.....
......
~;
$ci{'Q'} = qq~
.XXX..
X...X.
X...X.
X...X.
X.X.X.
X..X..
.XX.X.
......
......
~;
$ci{'q'} = qq~
......
......
.XXXX.
X...X.
X...X.
.XXXX.
....X.
....X.
......
~;
$ci{'R'} = qq~
XXXX..
X...X.
X...X.
XXXX..
X.X...
X..X..
X...X.
......
......
~;
$ci{'r'} = qq~
......
......
X.XXX.
XX....
X.....
X.....
X.....
......
......
~;
$ci{'S'} = qq~
.XXX..
X...X.
X.....
.XXX..
....X.
X...X.
.XXX..
......
......
~;
$ci{'s'} = qq~
......
......
.XXXX.
X.....
.XXX..
....X.
XXXX..
......
......
~;
$ci{'T'} = qq~
XXXXX.
..X...
..X...
..X...
..X...
..X...
..X...
......
......
~;
$ci{'t'} = qq~
.X....
XXXX..
.X....
.X....
.X....
.X..X.
..XX..
......
......
~;
$ci{'U'} = qq~
X...X.
X...X.
X...X.
X...X.
X...X.
X...X.
.XXX..
......
......
~;
$ci{'u'} = qq~
......
......
X...X.
X...X.
X...X.
X..XX.
.XX.X.
......
......
~;
$ci{'V'} = qq~
X...X.
X...X.
X...X.
X...X.
X...X.
.X.X..
..X...
......
......
~;
$ci{'v'} = qq~
......
......
X...X.
X...X.
X...X.
.X.X..
..X...
......
......
~;
$ci{'W'} = qq~
X...X.
X...X.
X...X.
X.X.X.
X.X.X.
XX.XX.
X...X.
......
......
~;
$ci{'w'} = qq~
......
......
X...X.
X...X.
X.X.X.
X.X.X.
XX.XX.
......
......
~;
$ci{'X'} = qq~
X...X.
X...X.
.X.X..
..X...
.X.X..
X...X.
X...X.
......
......
~;
$ci{'x'} = qq~
......
......
X...X.
.X.X..
..X...
.X.X..
X...X.
......
......
~;
$ci{'Y'} = qq~
X...X.
X...X.
.X.X..
..X...
..X...
..X...
..X...
......
......
~;
$ci{'y'} = qq~
......
......
X...X.
X...X.
X...X.
.XXXX.
....X.
.XXX..
......
~;
$ci{'Z'} = qq~
XXXXX.
....X.
...X..
..X...
.X....
X.....
XXXXX.
......
......
~;
$ci{'z'} = qq~
......
......
XXXXX.
...X..
..X...
.X....
XXXXX.
......
......
~;
#
###############################################

my($nl, @lines, $len, $w, $h, $LINE_HEIGHT);

# to measure length of the 'newline' character (cross platform LF vs CR+LF ???)
$nl = length qq~
~;

$LINE_HEIGHT = $CHAR_HEIGHT * $DOT_HEIGHT;
@lines = split("\n", $msg);
$len = 0;
foreach (@lines) { $len = length $_ if (length $_ > $len); }
$w = $len * $CHAR_WIDTH * $DOT_WIDTH;
$h = @lines * $LINE_HEIGHT;

# Implementation notes:
# * Image is NOT compressed! - Does not use LZW compression!

print 'Content-type: image/gif', "\x0A\x0A";

# GIF Signature

print $transidx ? 'GIF89a' : 'GIF87a';

# Screen Descriptor

# width, height
print pack 'v2', $w, $h; 
# global colour map, 8 bits colour resolution
print pack 'C', 0xF0 + $BITS_PER_PIXEL - 1;
# background colour = 0
print "\0";
# reserved
print "\0";

# Global Colour Map

print $palette;
print "\0" x ((2**$BITS_PER_PIXEL * 3) - length $palette);

if ($transidx) {
  # Graphic Control Extension
  
  # extension introducer
  print "\x21";
  # graphic control label
  print "\xF9";
  # block size
  print "\x04";
  # no disposal method, no user input, transparent colour present
  print "\x01";
  # delay time
  print "\0\0";
  # transparent colour index
  print $transidx;
  # block terminator
  print "\0";
}

# Image Descriptor

# image separator
print ',';
# left, top
print "\0\0\0\0";
# width, height
print pack 'v2', $w, $h;
# use global colour map (not local), sequential (not interlaced) 
print "\0";

# Raster Data

# code size
print pack 'C', $BITS_PER_PIXEL;

# build the image into a string, one byte per pixel
my($img, $line);
my($y, $cy, $dy);
my($x, $cx, $i, $c, $d, $di, $r);
for ($y = 0; $y < $h; $y++) {
  $cy = int($y / $DOT_HEIGHT) % $CHAR_HEIGHT; # y coord in character dots
  $dy = $y % $DOT_HEIGHT;
  for ($x = 0; $x < $w; $x += $DOT_WIDTH) {
    $cx = int($x / $DOT_WIDTH) % $CHAR_WIDTH; # x coord in character dots
    $i = int($x / $DOT_WIDTH / $CHAR_WIDTH); # index into message string
    $line = $lines[$y / $LINE_HEIGHT];
    $c = ($i < length $line) ? substr $line, $i, 1 : ' '; 
    $d = substr $ci{$c}, $cy * ($CHAR_WIDTH + $nl) + $cx + $nl, 1; # dot in character definition
    $di = ($d eq 'X') ? $dot : $nodot;
    $di = substr $di, $dy * ($DOT_WIDTH + $nl) + $nl, $DOT_WIDTH;
    for ($i = 0; $i < length $di; $i++) {
      $c = ord substr $di, $i, 1;
      
      # Start of randomizer - comment this block out if you don't like it!
      $r = rand;
      if ($r < .2) {
        $c += 1;
      } elsif ($r > .8) {
        $c += 2;
      }
      # End of randomizer
      
      $c = chr $c;
      $img .= $c;
    }
  }
}
# Re-arrange the image data so it's bit-packed
my($cnt, $pkdimg, $buf, $bufbits);
$i = 0;
$buf = 0;
$bufbits = 0;
while ($i <= length $img) {
  if ($i < length $img) {
    # Output each pixel
    $c = ord substr $img, $i, 1;
    $c &= 2**$BITS_PER_PIXEL-1;
    $buf |= $c << $bufbits;
    $bufbits += $BITS_PER_PIXEL + 1;
    $i++;
    # Insert LZW table clear code before the decoder will grow the bit size
    # The minus 2 is a fudge factor
    if ($i % (2**$BITS_PER_PIXEL-2) == 0) {
      $c = 2**$BITS_PER_PIXEL;
      $buf |= $c << $bufbits;
      $bufbits += $BITS_PER_PIXEL + 1;
    }
  } else {
    #Output LZW end code
    $c = 2**$BITS_PER_PIXEL+1;
    $buf |= $c << $bufbits;
    $bufbits += $BITS_PER_PIXEL + 1;
    $i++;
  }
  while ($bufbits >= 8) {
    $c = chr ($buf & 255);
    $pkdimg .= $c;
    $buf >>= 8;
    $bufbits -= 8;
  }
}
$pkdimg .= chr $buf;
# Output image data
$i = 0;
while ($i < length $pkdimg) {
  $cnt = (length $pkdimg) - $i;
  $cnt = 255 if ($cnt > 255);
  print pack 'C', $cnt;
  print substr $pkdimg, $i, $cnt;
  $i += $cnt;
}
# Finish up
print "\0"; # zero byte count (end of raster data)

# GIF Terminator

print ';';

}

1;

#####################################################################
# End of file "msgimg.pl"                                           #
#####################################################################
__END__

-----BEGIN PGP SIGNATURE-----

iQA/AwUBWk4Wzcr7q1ZyCqQiEQL6jwCgjTAb49WCvLbWau8BTFiJ8pOLMQoAn2g9
Xq8B8iVzXW20pHXZPo1prCHF
=daDO
-----END PGP SIGNATURE-----
